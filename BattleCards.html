<!doctype html>
<html lang="he" dir="rtl">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
    <title>Battle Cards — גרסה משודרגת</title>
    <style>
        :root{
            --hand-h:108px;
            --pad:8px;
            --bg-you:#0b2012;
            --bg-enemy:#200b0b;
            --panel:#111827;
            --card:#1f2937;
            --ink:#fff;
        }
        *{box-sizing:border-box}
        html,body{height:100%;margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Noto Sans',Ubuntu,'Helvetica Neue',Arial}
        body{overflow:hidden;transition:background 0.4s;color:#fff}
        #wrap{position:fixed;inset:0;display:flex;flex-direction:column}
        #top{height:44px;display:flex;align-items:center;justify-content:space-between;padding:0 var(--pad);background:linear-gradient(90deg,#0e1626,#0b1220);box-shadow:0 2px 6px rgba(0,0,0,.5);font-weight:700;z-index:3}
        #titleLeft {
            display: flex;
            align-items: center;
            font-size: 16px;
        }
        #turnPrefix {
            margin-right: 4px;
            opacity: 0.8;
        }
        #status{font-weight:600;font-size:14px;opacity:.9}
        #gameWrap{flex:1;min-height:0;display:flex;align-items:center;justify-content:center;padding:var(--pad);position:relative}
        #statsPanel{
            position:absolute;
            left:8px;
            top:52px;
            bottom:var(--hand-h);
            width:160px;
            background:rgba(0,0,0,0.5);
            border:1px solid rgba(255,255,255,.15);
            border-radius:10px;padding:6px;font-size:13px;overflow-y:auto;color:#fff;
            transition: transform 0.3s ease-in-out;
            z-index: 5;
        }
        #statsPanel.closed {
            transform: translateX(calc(-100% - 8px));
        }
        #statsPanel h4{margin:4px 0;font-size:14px;text-align:center}
        #statsPanel p{margin:2px 0;font-size:12px;color:#fff}
        canvas{display:block;background:#071021;border-radius:12px;max-width:100%;height:100%;touch-action:none}
        #hand{height:var(--hand-h);display:flex;gap:8px;align-items:center;overflow-x:auto;padding:8px;background:var(--panel);border-top:1px solid rgba(255,255,255,.06);z-index:3}
        .card{min-width:104px;background:var(--card);padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,.08);box-shadow:0 3px 8px rgba(0,0,0,.5);flex:0 0 auto;cursor:pointer;text-align:center;color:#fff;position:relative;overflow:hidden}
        .card h4{margin:4px 0 2px;font-size:13px}
        .card p{margin:0;font-size:11px;opacity:.85}
        .ic{font-size:18px;line-height:1}
        .sel{outline:3px solid #3b82f6}
        .pill{font-size:12px;padding:2px 8px;border:1px solid rgba(255,255,255,.12);border-radius:999px}
        #victoryOverlay{
            position:fixed;inset:0;background:rgba(0,0,0,.75);
            display:flex;flex-direction:column;align-items:center;justify-content:center;
            color:#fff;font-size:24px;z-index:99;opacity:0;pointer-events:none;transition:opacity .4s;
        }
        #victoryOverlay.active{opacity:1;pointer-events:auto;}
        #victoryOverlay button{
            margin-top:20px;padding:10px 20px;font-size:18px;border:none;border-radius:10px;background:#3b82f6;color:#fff;cursor:pointer;
        }
        .upgradeIcons{margin-top:4px;font-size:16px;}
        #closeStatsBtn {
            position: absolute;
            top: 6px;
            right: 6px;
            background: none;
            border: none;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
        }
        #howToModal {
            display:none;
            position:fixed;
            inset:0;
            z-index:100;
            background:rgba(0,0,0,0.8);
            color:#fff;
            align-items:center;
            justify-content:center;
            font-size:18px;
        }
        #howToModal > div {
            background:#222;
            padding:32px 24px;
            border-radius:16px;
            max-width:400px;
            margin:auto;
            position:relative;
        }
        #howToModal button {
            position:absolute;
            top:12px;
            right:12px;
            background:none;
            border:none;
            color:#fff;
            font-size:22px;
            cursor:pointer;
        }
        /* language toggle button */
        #langToggle{
            min-width:56px;
            height:30px;
            border-radius:8px;
            background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(0,0,0,0.12));
            border:1px solid rgba(255,255,255,0.08);
            display:inline-flex;align-items:center;justify-content:center;
            font-weight:700;cursor:pointer;margin-right:8px;color:#fff
        }
        /* developer credits */
        #devCredits{
            position:fixed;left:8px;bottom:8px;z-index:60;
            background:rgba(0,0,0,0.35);color:#fff;padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);
            font-size:13px;opacity:0.95;backdrop-filter: blur(4px);
        }
    </style>
</head>
<body>
    <div id="wrap">
        <div id="top">
            <div id="titleLeft">Battle Cards — <span id="turnPrefix">תור:</span> <span id="turnLabel">אתה</span></div>
            <div id="status" class="pill">פעולה אחת לתור</div>
            <div style="display:flex;align-items:center">
                <button id="langToggle" class="pill">HE</button>
                <button id="howToBtn" class="pill" style="margin-right:8px;">איך משחקים?</button>
            </div>
        </div>
        <div id="gameWrap">
            <canvas id="cv"></canvas>
            <div id="statsPanel">
                <button id="closeStatsBtn">✕</button>
                <h4>סטטיסטיקות</h4>
                <p>🪖 חייל רגיל — HP:2, פגיעה:70%</p>
                <p>🎯 צלף — HP:1, טווח:3, פגיעה:80%</p>
                <p>🛡️ חייל כבד — HP:3, פגיעה:60%</p>
                <hr>
                <p>🔫 רובה — מוריד לב נוסף (בלי רובה אי אפשר לירות)</p>
                <p>🔭 כוונת — מעלה דיוק ב10%</p>
                <p>💙 שריון — מעלה הגנה</p>
                <small>שדרוגים מצטברים!</small>
            </div>
        </div>
        <div id="hand"></div>
    </div>
    <div id="devCredits">Developers: Ofer, Gome and ChatGPT</div>
    <div id="victoryOverlay">
        <div id="victoryText"></div>
        <div id="victoryStats"></div>
        <button onclick="location.reload()">רענן להתחלה מחדש</button>
    </div>
    <div id="howToModal">
        <div>
            <button id="closeHowToBtn">✕</button>
            <h2 style="text-align:center;font-size:2em;">
                איך משחקים? <span class="bounce">🎲</span>
            </h2>
            <p style="font-size:1.1em;line-height:1.7;">
                <span class="pulse">🎯</span> <b>מטרה:</b> להוביל <span style="color:#10b981;">חייל שלך</span> לשורה הראשונה של היריב!<br><br>
                <span class="pulse">🃏</span> <b>כל תור:</b> פעולה אחת בלבד!<br>
                <span style="color:#ffd166;">➤</span> <b>הנחת קלף:</b> בחר קלף מהיד <span class="bounce">👇</span> ולחץ על תא פנוי בשורה שלך.<br>
                <span style="color:#3b82f6;">➤</span> <b>שדרוג:</b> בחר שדרוג/נשק <span class="bounce">🔫</span> ולחץ על חייל שלך.<br>
                <span style="color:#ef4444;">➤</span> <b>תקיפה:</b> בחר חייל שלך <span class="bounce">🪖</span> ואז לחץ על אויב בטווח.<br>
                <span class="pulse">🏆</span> <b>ניצחון:</b> הראשון שמוביל חייל לשורה של היריב מנצח!<br>
            </p>
            <div style="text-align:center;margin-top:18px;">
                <span class="firework">✨</span>
                <span class="firework">🔥</span>
                <span class="firework">💥</span>
                <span class="firework">🎉</span>
            </div>
        </div>
    </div>
    <script>
        const cv = document.getElementById('cv');
        const ctx = cv.getContext('2d');
        const handEl = document.getElementById('hand');
        const turnLabel = document.getElementById('turnLabel');
        const victoryOverlay = document.getElementById('victoryOverlay');
        const victoryText = document.getElementById('victoryText');
        const victoryStats = document.getElementById('victoryStats');
        const statsPanel = document.getElementById('statsPanel');
        const closeStatsBtn = document.getElementById('closeStatsBtn');
        const howToBtn = document.getElementById('howToBtn');
        const howToModal = document.getElementById('howToModal');
        const closeHowToBtn = document.getElementById('closeHowToBtn');

        // --- Internationalization (Hebrew / English) ---
        let currentLang = 'he';
        const translations = {
            he: {
                title: 'Battle Cards',
                turnPrefix: 'תור:',
                status: 'פעולה אחת לתור',
                howTo: 'איך משחקים?',
                statsHeader: 'סטטיסטיקות',
                statsItems: [
                    '🪖 חייל רגיל — HP:2, פגיעה:70%',
                    '🎯 צלף — HP:1, טווח:3, פגיעה:80%',
                    '🛡️ חייל כבד — HP:3, פגיעה:60%'
                ],
                weaponDesc: '🔫 רובה — מוריד לב נוסף (בלי רובה אי אפשר לירות)',
                scopeDesc: '🔭 כוונת — מעלה דיוק ב10%',
                armorDesc: '💙 שריון — מעלה הגנה',
                howToLines: [
                    '🎯 מטרת המשחק: להוביל חייל לשורה של היריב!',
                    '🃏 כל תור: פעולה אחת בלבד.',
                    '➤ ההנחה: בחר קלף מהיד ולחץ על תא פנוי בשורה שלך.',
                    '➤ שדרוג: בחר שדרוג/נשק ולחץ על חייל שלך.',
                    '➤ תקיפה: בחר חייל ואז לחץ על אויב בטווח.'
                ],
                refresh: 'רענן להתחלה מחדש',
                wonSuffix: 'ניצח! 🎉',
                you: 'אתה',
                enemy: 'אויב',
                hp: 'HP',
                range: 'טווח',
                weapon: 'נשק',
                scope: 'כוונת',
                armor: 'שריון'
            },
            en: {
                title: 'Battle Cards',
                turnPrefix: 'Turn:',
                status: 'One action per turn',
                howTo: 'How to play?',
                statsHeader: 'Statistics',
                statsItems: [
                    '🪖 Soldier — HP:2, Hit:70%',
                    '🎯 Sniper — HP:1, Range:3, Hit:80%',
                    '🛡️ Heavy Trooper — HP:3, Hit:60%'
                ],
                weaponDesc: '🔫 Rifle — extra damage (need Rifle to shoot)',
                scopeDesc: '🔭 Scope — +10% accuracy',
                armorDesc: '💙 Armor — adds protection',
                howToLines: [
                    '🎯 Objective: get one of your soldiers to the opponent top row!',
                    '🃏 Each turn: one action only.',
                    '➤ Place: pick a card from hand and click an empty cell on your row.',
                    '➤ Upgrade: pick an upgrade/weapon and click your soldier.',
                    '➤ Attack: pick your soldier and click an enemy in range.'
                ],
                refresh: 'Restart',
                wonSuffix: 'won! 🎉',
                you: 'You',
                enemy: 'Enemy',
                hp: 'HP',
                range: 'Range',
                weapon: 'Weapon',
                scope: 'Scope',
                armor: 'Armor'
            }
        };

        const cardNameMap = {
            'חייל רגיל': {he:'חייל רגיל', en:'Soldier'},
            'צלף': {he:'צלף', en:'Sniper'},
            'חייל כבד': {he:'חייל כבד', en:'Heavy Trooper'},
            'רובה': {he:'רובה', en:'Rifle'},
            'שריון': {he:'שריון', en:'Armor'},
            'כוונת': {he:'כוונת', en:'Scope'}
        };

        function t(key){
            const part = translations[currentLang];
            return part && part[key] ? part[key] : key;
        }

        function displayCardName(card){
            if(!card || !card.name) return '';
            const map = cardNameMap[card.name];
            return map ? map[currentLang] : card.name;
        }

        function applyLanguage(){
            document.title = translations[currentLang].title;
            // header
            document.getElementById('turnPrefix').textContent = translations[currentLang].turnPrefix;
            turnLabel.textContent = translations[currentLang][ players[currentPlayer].owner===OWNER.YOU ? 'you' : 'enemy' ];
            document.getElementById('status').textContent = translations[currentLang].status;
            document.getElementById('howToBtn').textContent = translations[currentLang].howTo;
            const langBtn = document.getElementById('langToggle');
            langBtn.textContent = currentLang === 'he' ? 'HE' : 'EN';
            // stats panel
            const statsPanelEl = document.getElementById('statsPanel');
            const closeBtn = document.getElementById('closeStatsBtn');
            statsPanelEl.innerHTML = '';
            statsPanelEl.appendChild(closeBtn);
            const h4 = document.createElement('h4'); h4.textContent = translations[currentLang].statsHeader; statsPanelEl.appendChild(h4);
            translations[currentLang].statsItems.forEach(line=>{ const p=document.createElement('p'); p.textContent=line; statsPanelEl.appendChild(p); });
            const hr = document.createElement('hr'); statsPanelEl.appendChild(hr);
            const p1 = document.createElement('p'); p1.textContent = translations[currentLang].weaponDesc; statsPanelEl.appendChild(p1);
            const p2 = document.createElement('p'); p2.textContent = translations[currentLang].scopeDesc; statsPanelEl.appendChild(p2);
            const p3 = document.createElement('p'); p3.textContent = translations[currentLang].armorDesc; statsPanelEl.appendChild(p3);
            const small = document.createElement('small'); small.textContent = currentLang==='he' ? 'שדרוגים מצטברים!' : 'Upgrades stack!'; statsPanelEl.appendChild(small);
            // how-to modal (preserve close button)
            const howToInner = document.querySelector('#howToModal > div');
            const closeHow = document.getElementById('closeHowToBtn');
            howToInner.innerHTML = '';
            howToInner.appendChild(closeHow);
            const h2 = document.createElement('h2'); h2.style.textAlign='center'; h2.style.fontSize='2em'; h2.innerHTML = (currentLang==='he'? 'איך משחקים?':'How to play?') + ' <span class="bounce">🎲</span>';
            howToInner.appendChild(h2);
            const p = document.createElement('p'); p.style.fontSize='1.1em'; p.style.lineHeight='1.7';
            p.innerHTML = translations[currentLang].howToLines.map(l=> l + '<br>').join('');
            howToInner.appendChild(p);
            const footer = document.createElement('div'); footer.style.textAlign='center'; footer.style.marginTop='18px'; footer.innerHTML = '<span class="firework">✨</span><span class="firework">🔥</span><span class="firework">💥</span><span class="firework">🎉</span>';
            howToInner.appendChild(footer);
            // victory overlay button
            const vicBtn = document.querySelector('#victoryOverlay button');
            if(vicBtn) vicBtn.textContent = translations[currentLang].refresh;
            // re-render hand and redraw
            renderHand();
             draw();
        }

        document.addEventListener('DOMContentLoaded', ()=>{
            const langToggle = document.getElementById('langToggle');
            if(langToggle){
                langToggle.addEventListener('click', ()=>{
                    currentLang = currentLang === 'he' ? 'en' : 'he';
                    applyLanguage();
                });
            }
            applyLanguage();
        });

        let dpr = Math.max(1, window.devicePixelRatio || 1);
        let view = { w: 4, h: 4 };
        let CELL_W = 120, CELL_H = 140, GAP = 8;

        function resize() {
            const H_HAND = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--hand-h')) || 108;
            const topH = 44;
            const availW = window.innerWidth - 2*8 - 160;
            const availH = window.innerHeight - topH - H_HAND - 2*8;
            const cellAspect = CELL_H / CELL_W;
            const maxCellW = Math.floor((availW - (view.w+1)*GAP) / view.w);
            const maxCellH = Math.floor((availH - (view.h+1)*GAP) / view.h);
            const candidateW = Math.min(maxCellW, Math.floor(maxCellH / cellAspect));
            CELL_W = Math.max(70, candidateW);
            CELL_H = Math.max(90, Math.floor(CELL_W * cellAspect));
            const pixelW = (view.w*CELL_W + (view.w+1)*GAP);
            const pixelH = (view.h*CELL_H + (view.h+1)*GAP);
            cv.style.width = pixelW + 'px';
            cv.style.height = pixelH + 'px';
            cv.width = Math.floor(pixelW * dpr);
            cv.height = Math.floor(pixelH * dpr);
            ctx.setTransform(dpr,0,0,dpr,0,0);
            draw();
        }
        window.addEventListener('resize', resize);
        
        closeStatsBtn.addEventListener('click', () => {
            statsPanel.classList.toggle('closed');
        });

        howToBtn.addEventListener('click', () => {
            howToModal.style.display = 'flex';
        });
        closeHowToBtn.addEventListener('click', () => {
            howToModal.style.display = 'none';
        });

        const ROWS = 4, COLS = 4;
        const OWNER = { YOU: 0, ENEMY: 1 };
        const board = Array.from({length: ROWS}, () => Array(COLS).fill(null));

        function makeSoldier(name,hp,range=1,role='חייל'){
            return {type:'soldier',name,role,hp,maxHp:hp,range,owner:null,id:crypto.randomUUID(),weapons:[],upgrades:[]};
        }
        function makeWeapon(name,bonus=1){
            return {type:'weapon',name,bonus,id:crypto.randomUUID()};
        }
        function makeUpgrade(name,kind='armor',val=1){
            return {type:'upgrade',name,kind,val,id:crypto.randomUUID()};
        }

        const BASE_POOL=[
            makeSoldier('חייל רגיל',2,1,'חייל'),
            makeSoldier('צלף',1,2,'צלף'),
            makeSoldier('חייל כבד',3,1,'כבד'),
            makeSoldier('חייל רגיל',2,1,'חייל'),
            makeSoldier('צלף',1,2,'צלף'),
            makeSoldier('חייל כבד',3,1,'כבד'),
            makeWeapon('רובה',1),
            makeWeapon('רובה',1),
            makeWeapon('רובה',1),
            makeUpgrade('שריון','armor',1),
            makeUpgrade('כוונת','scope',1)
        ];

        function clone(o){return JSON.parse(JSON.stringify(o));}
        function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

        function createPlayer(name,owner){return{name,owner,deck:shuffle(BASE_POOL.concat(BASE_POOL)),hand:[],kills:0,turns:0};}
        const players=[createPlayer('אתה',OWNER.YOU),createPlayer('אויב',OWNER.ENEMY)];
        let currentPlayer=0,gameOver=false,actionLocked=false,selectedCell=null,selectedHand=null;

        function hasUnitsOnBoard(owner){
            for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(board[r][c]&&board[r][c].owner===owner)return true;
            return false;
        }

        function drawCardFor(pIdx,count=1){
            const p=players[pIdx];
            for(let i=0;i<count;i++){
                if(p.deck.length===0)break;
                let card=p.deck.pop();
                if(!hasUnitsOnBoard(p.owner) && card.type!=='soldier'){
                    card=clone(makeSoldier('חייל רגיל',2,1,'חייל'));
                }
                p.hand.push(card);
            }
        }
        drawCardFor(0,3);
        drawCardFor(1,3);

        function cellRect(r,c){const x=GAP+c*CELL_W+c*GAP;const y=GAP+r*CELL_H+r*GAP;return{x,y,w:CELL_W,h:CELL_H};}

        function iconFor(card){
            if(card.type==='soldier'){
                return card.role==='צלף'?'🎯':card.role==='כבד'?'🛡️':'🪖';
            } else if(card.type==='weapon') return '🔫';
            else if(card.type==='upgrade' && card.kind==='scope') return '🔭';
            else return '💙';
        }

        function getTotalHP(unit) {
            const armorCount = unit.upgrades ? unit.upgrades.filter(up=>up.kind==='armor').length : 0;
            return unit.maxHp + armorCount;
        }
        function drawHearts(u, x, y){
            const armorCount = u.upgrades ? u.upgrades.filter(up => up.kind==='armor').length : 0;
            const totalHearts = u.hp + armorCount;
            const heartsWidth = totalHearts * 14; 
            const startX = x + (CELL_W - heartsWidth) / 2;
            const startY = y + CELL_H - 20;

            // Draw armor hearts (blue)
            for(let i=0; i<armorCount; i++){
                const bx = startX + i*14, by = startY;
                ctx.font = '12px system-ui';
                ctx.fillText('💙', bx+1, by+12);
            }

            // Draw HP hearts (red)
            for(let i=0; i<u.hp; i++){
                const bx = startX + (armorCount*14) + i*14, by = startY;
                ctx.font = '12px system-ui';
                ctx.fillText('❤️', bx+1, by+12);
            }
        }


        function getHitChance(unit){
            let base=1.0;
            if(unit.role==='חייל') base=0.7;
            if(unit.role==='כבד') base=0.6;
            if(unit.role==='צלף') base=0.8;
            const scopes = unit.upgrades ? unit.upgrades.filter(up=>up.kind==='scope').length : 0;
            if(scopes > 0) base += 0.1 * scopes;
            base = Math.min(1,base);
            return base;
        }

        function drawUpgradeIcons(u, x, y, h) {
            let icons = u.weapons.map(w => '🔫')
                .concat(u.upgrades.filter(up => up.kind === 'scope').map(up => iconFor(up)))
                .concat(u.upgrades.filter(up => up.kind === 'armor').map(up => iconFor(up)));
            let totalWidth = icons.length * 20;
            let startX = x + (CELL_W - totalWidth) / 2;
            
            ctx.font = '16px sans-serif';
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'center';

            icons.forEach((icon, i) => {
                ctx.fillText(icon, startX + i * 20 + 10, y + h - 50);
            });
        }

        // אנימציה לגז רעיל
        let gasPulseCells = [];
        function draw(){
            ctx.clearRect(0,0,cv.width,cv.height);
            for(let r=0;r<ROWS;r++){
                for(let c=0;c<COLS;c++){
                    const {x,y,w,h}=cellRect(r,c);
                    ctx.fillStyle=(r<2)?'#092033':'#072022';
                    ctx.fillRect(x,y,w,h);
                    ctx.strokeStyle='rgba(255,255,255,.08)';
                    ctx.strokeRect(x,y,w,h);
                }
            }
            // ציור חיילים וכו'
            for(let r=0;r<ROWS;r++){
                for(let c=0;c<COLS;c++){
                    const u=board[r][c];
                    if(!u)continue;
                    ctx.save();
                    ctx.beginPath();
                    const {x,y,w,h}=cellRect(r,c);
                    ctx.rect(x+2, y+2, w-4, h-4);
                    ctx.clip();
                    if(u.type==='soldier'){
                        ctx.fillStyle = u.owner === OWNER.YOU ? '#10b981' : '#ef4444';
                        ctx.beginPath();
                        ctx.arc(x+w/2, y + 25, 16, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = '20px sans-serif';
                        ctx.textAlign='center';
                        ctx.textBaseline='middle';
                        ctx.fillStyle = '#fff';
                        ctx.fillText(iconFor(u), x+w/2, y+25);
                        drawUpgradeIcons(u, x, y, h);
                    }
                    drawHearts(u, x, y);
                    ctx.restore();
                }
            }
            if(selectedCell){
                const {x,y,w,h}=cellRect(selectedCell.row,selectedCell.col);
                ctx.save();ctx.strokeStyle='#3b82f6';ctx.lineWidth=3;ctx.strokeRect(x,y,w,h);ctx.restore();
            }
            renderProjectiles();
        }

        function renderHand(){
            const p=players[currentPlayer];
            handEl.innerHTML='';
            p.hand.forEach((card,idx)=>{
                const el=document.createElement('div');
                el.className='card';
                el.style.position='relative';
                // translated card name and description
                let desc = '';
                if(card.type==='soldier'){
                    desc = `${translations[currentLang].hp}:${getTotalHP(card)} • ${translations[currentLang].range}:${card.range}`;
                } else if(card.type==='weapon'){
                    desc = translations[currentLang].weapon;
                } else if(card.type==='upgrade' && card.kind==='scope'){
                    desc = translations[currentLang].scope;
                } else {
                    desc = translations[currentLang].armor;
                }
                el.innerHTML = `<div class="ic">${iconFor(card)}</div> <h4>${displayCardName(card)}</h4> <p>${desc}</p>`;
                 el.onclick=()=>{
                     selectedCell=null;
                     selectedHand=(selectedHand===idx?null:idx);
                     document.querySelectorAll('.card').forEach((n,i)=>n.classList.toggle('sel',i===selectedHand));
                 };
                handEl.appendChild(el);
            });
        }
        
        function shoot(unit,target,fromCell,toCell,cb){
            const weaponsCount = unit.weapons.filter(w=>w.name==='רובה').length;
            if(weaponsCount===0){
                if(cb) cb(false);
                return;
            }

            let shotsRemaining = weaponsCount;
            const onShotComplete = (shotWasSuccessful) => {
                if (shotWasSuccessful) {
                    if (target.hp <= 0 && (target.upgrades ? target.upgrades.filter(up => up.kind === 'armor').length === 0 : true)) {
                        if (target.type === 'soldier') {
                            board[toCell.row][toCell.col] = null;
                        }
                        players[currentPlayer].kills++;
                    }
                }
                shotsRemaining--;
                if (shotsRemaining <= 0) {
                    cb(true);
                }
            };
            
            for (let i = 0; i < weaponsCount; i++) {
                setTimeout(() => {
                    launchProjectileCustom(fromCell, toCell, () => {
                        let hitSuccess = (Math.random() < getHitChance(unit));
                        if (hitSuccess) {
                            let damage = 1;
                            while (damage > 0) {
                                let armorIdx = target.upgrades ? target.upgrades.findIndex(up => up.kind === 'armor') : -1;
                                if (armorIdx >= 0) {
                                    target.upgrades.splice(armorIdx, 1);
                                    damage--;
                                } else if (target.hp > 0) {
                                    target.hp -= 1;
                                    damage--;
                                } else {
                                    break;
                                }
                            }
                        } else {
                            let missRow = Math.floor(Math.random() * ROWS);
                            let missCol = Math.floor(Math.random() * COLS);
                            launchProjectileCustom(fromCell, { row: missRow, col: missCol }, () => {});
                        }
                        onShotComplete(hitSuccess);
                        draw();
                    });
                }, i * 400); // 400ms delay between shots
            }
        }

        function launchProjectileCustom(fromCell,toCell,onDone){
            const sf=cellRect(fromCell.row,fromCell.col),tf=cellRect(toCell.row,toCell.col);
            const sx=sf.x+sf.w/2,sy=sf.y+sf.h/2,ex=tf.x+tf.w/2,ey=tf.y+tf.h/2;
            projectiles.push({sx,sy,ex,ey,start:performance.now(),dur:280,cb:onDone});
            if(!animRAF)animRAF=requestAnimationFrame(tick);
        }

        function inBounds(r,c){return r>=0&&r<ROWS&&c>=0&&c<COLS;}
        function isOwnPlacementRow(owner,row){return owner===OWNER.YOU?(row>=2):(row<2);}
        
        function isAdjacent(from,to){
            const dr=Math.abs(from.row-to.row),dc=Math.abs(from.col-to.col);
            return ((dr===1 && dc===0)||(dr===0 && dc===1));
        }
        
        function isAttackable(from, to, unit){
            const dr=Math.abs(from.row-to.row),dc=Math.abs(from.col-to.col);
            if (unit.range === 1) {
                return (dr === 1 && dc === 0) || (dr === 0 && dc === 1) || (dr===1 && dc===1);
            }
            if (unit.range === 2) {
                return Math.max(dr, dc) <= 2 && !(dr === 0 && dc === 0);
            }
            return false;
        }

        function checkVictoryNow(){
            let youWin = false, enemyWin = false;
            for (let c = 0; c < COLS; c++) {
                if (board[0][c] && board[0][c].owner === OWNER.YOU) youWin = true;
            }
            for(let c=0; c<COLS; c++){
                if(board[ROWS-1][c] && board[ROWS-1][c].owner === OWNER.ENEMY) enemyWin = true;
            }
            if(youWin || enemyWin){
                gameOver = true;
                setTimeout(() => {
                    if(youWin) showVictory(players[OWNER.YOU]);
                    else showVictory(players[OWNER.ENEMY]);
                }, 200);
                return true;
            }
            return false;
        }

        function showVictory(winner) {
            const totalTurns = players[0].turns + players[1].turns;
            const winnerLabel = winner.owner===OWNER.YOU ? translations[currentLang].you : translations[currentLang].enemy;
            victoryText.textContent = `${winnerLabel} ${translations[currentLang].wonSuffix}`;
            if(currentLang === 'he'){
                victoryStats.innerHTML = `סה״כ סיבובים: ${totalTurns}<br>` + `הרגים: אתה ${players[0].kills}, אויב ${players[1].kills}`;
            } else {
                victoryStats.innerHTML = `Total turns: ${totalTurns}<br>` + `Kills: You ${players[0].kills}, Enemy ${players[1].kills}`;
            }
             victoryOverlay.classList.add('active');
             launchFireworks();
         }

        function beginTurn(pIdx){
             currentPlayer=pIdx;
             document.body.style.background=currentPlayer===0?'var(--bg-you)':'var(--bg-enemy)';
             players[currentPlayer].turns++;
             turnLabel.textContent = translations[currentLang][ players[currentPlayer].owner===OWNER.YOU ? 'you' : 'enemy' ];
             selectedCell=null;selectedHand=null;
             drawCardFor(currentPlayer,1);
             renderHand();draw();
         }

        function endTurnAfter(ms=400){
            actionLocked=true;
            setTimeout(()=>{
                actionLocked=false;
                if(!gameOver)beginTurn(1-currentPlayer);
            },ms);
        }
        const projectiles=[];
        let animRAF=null;

        function renderProjectiles(){
            ctx.save();
            for(const p of projectiles){
                const t=Math.min(1,(performance.now()-p.start)/p.dur);
                const x=p.sx+(p.ex-p.sx)*t;
                const y = p.sy + (p.ey - p.sy) * t;
                ctx.fillStyle = '#ffd166';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function tick(){
            draw();
            const now = performance.now();
            for(let i = projectiles.length - 1; i >= 0; i--){
                if(now - projectiles[i].start >= projectiles[i].dur){
                    const cb = projectiles[i].cb;
                    projectiles.splice(i,1);
                    if(typeof cb === 'function') cb();
                }
            }
            if(projectiles.length > 0){
                animRAF = requestAnimationFrame(tick);
            } else {
                animRAF = null;
            }
        }

        cv.addEventListener('pointerdown', (ev)=>{
            if(gameOver || actionLocked) return;
            const rect = cv.getBoundingClientRect();
            const x = ev.clientX - rect.left;
            const y = ev.clientY - rect.top;
            let row=-1, col=-1;
            for(let r=0;r<ROWS;r++){
                for(let c=0;c<COLS;c++){
                    const {x:cx, y:cy, w, h} = cellRect(r,c);
                    if(x>=cx && x<=cx+w && y>=cy && y<=cy+h){
                        row=r;
                        col=c;
                    }
                }
            }
            if(row<0) return;

            const me = players[currentPlayer];

            if(selectedHand !== null){
                const card = me.hand[selectedHand];
                if(card.type === 'soldier'){
                    // אפשר להניח חייל רק על תא פנוי בשורה שלך
                    if((!board[row][col]) && isOwnPlacementRow(me.owner,row)){
                        const u = clone(card);
                        u.owner=me.owner;
                        board[row][col]=u;
                        me.hand.splice(selectedHand,1);
                        selectedHand=null;
                        renderHand();
                        draw();
                        if(!checkVictoryNow()) endTurnAfter(250);
                    } else {
                        selectedHand=null;
                        renderHand();
                        draw();
                    }
                    return;
                } else {
                    const u = board[row][col];
                    if(u && u.owner===me.owner){
                        if(card.type==='weapon'){
                            u.weapons.push(clone(card));
                        } else if(card.type==='upgrade' && card.kind==='armor') {
                             u.upgrades.push(clone(card));
                        } else if (card.type === 'upgrade' && card.kind === 'scope') {
                            u.upgrades.push(clone(card));
                        }
                        me.hand.splice(selectedHand,1);
                        selectedHand=null;
                        renderHand();
                        draw();
                        if(!checkVictoryNow()) endTurnAfter(200);
                    } else {
                        selectedHand=null;
                        renderHand();
                        draw();
                    }
                    return;
                }
            }

            if(selectedCell){
                const from = selectedCell;
                const unit = board[from.row][from.col];
                if(!unit || unit.owner!==me.owner){
                    selectedCell=null;
                    draw();
                    return;
                }

                const target = board[row][col];
                
                if(target && target.owner!==me.owner && isAttackable(from, {row,col}, unit)){
                    actionLocked=true;
                    shoot(unit,target,from,{row,col},actionWas=>{
                        if(actionWas){
                            selectedCell=null;
                            draw();
                            if(!checkVictoryNow()) endTurnAfter(50);
                        } else {
                            actionLocked=false;
                        }
                    });
                    return;
                }
                
                if(unit.type === 'soldier' && !target && isAdjacent(from,{row,col})){
                    board[row][col]=unit;
                    board[from.row][from.col]=null;
                    selectedCell=null;
                    draw();
                    if(!checkVictoryNow()) endTurnAfter(120);
                    return;
                }

                selectedCell=null;
                draw();
                return;
            } else {
                const u = board[row][col];
                if(u && u.owner===me.owner){
                    selectedCell={row,col};
                    draw();
                }
            }
        });

        resize();
        draw();
        beginTurn(currentPlayer);

        function launchFireworks(){
            const fwCanvas = document.createElement('canvas');
            fwCanvas.style.position='fixed';
            fwCanvas.style.inset=0;
            fwCanvas.style.pointerEvents='none';
            document.body.appendChild(fwCanvas);
            fwCanvas.width = window.innerWidth;
            fwCanvas.height = window.innerHeight;
            const fctx = fwCanvas.getContext('2d');
            const particles=[];
            for(let i=0;i<100;i++){
                particles.push({
                    x: Math.random()*fwCanvas.width,
                    y: Math.random()*fwCanvas.height/2,
                    vx: (Math.random()-0.5)*4,
                    vy: Math.random()*-5-2,
                    color: `hsl(${Math.random()*360},100%,50%)`,
                    life: Math.random()*60+30
                });
            }
            function fwTick(){
                fctx.clearRect(0,0,fwCanvas.width,fwCanvas.height);
                for(const p of particles){
                    fctx.fillStyle=p.color;
                    fctx.beginPath();
                    fctx.arc(p.x,p.y,3,0,Math.PI*2);
                    fctx.fill();
                    p.x+=p.vx;
                    p.y+=p.vy;
                    p.vy+=0.1;
                    p.life--;
                }
                for(let i=particles.length-1;i>=0;i--)
                    if(particles[i].life<=0) particles.splice(i,1);
                if(particles.length>0) requestAnimationFrame(fwTick);
                else fwCanvas.remove();
            }
            fwTick();
        }
    </script>
</body>
</html>